<script context="module">const key = {};
function classes(classes2) {
  return classes2 ? classes2.split(" ").filter((x) => x) : [];
}
function nextFrame() {
  const raf = requestAnimationFrame;
  return new Promise((resolve) => raf(() => raf(resolve)));
}
</script>

<script>import { getContext, setContext, createEventDispatcher, tick } from "svelte";
import { writable } from "svelte/store";
export let show = null;
export let appear = false;
export let unmount = false;
export let enter = "";
export let enterFrom = "";
export let enterTo = "";
export let leave = null;
export let leaveFrom = null;
export let leaveTo = null;
$:
  enterClasses = classes(enter);
$:
  enterFromClasses = classes(enterFrom);
$:
  enterToClasses = classes(enterTo);
$:
  leaveClasses = classes(leave === null ? enter : leave);
$:
  leaveFromClasses = classes(leaveFrom === null ? enterTo : leaveFrom);
$:
  leaveToClasses = classes(leaveTo === null ? enterFrom : leaveTo);
const parent = show === null ? getContext(key) : null;
const { subscribe, set } = writable(show);
const context = {
  appear: parent ? parent.appear : appear,
  count: 0,
  show: { subscribe },
  completed: () => {
  }
};
setContext(key, context);
let display = show && !context.appear ? "contents" : "none";
let mounted = !unmount || show === true;
const dispatch = createEventDispatcher();
function transition(node, show2) {
  let el;
  function addClasses(...classes2) {
    el.classList.add(...classes2);
  }
  function removeClasses(...classes2) {
    el.classList.remove(...classes2);
  }
  function transitionEnd(transitions) {
    return transitions.length ? new Promise(
      (resolve) => el.addEventListener("transitionend", (e) => {
        e.stopPropagation();
        resolve();
      }, { once: true })
    ) : Promise.resolve();
  }
  function childrenCompleted(parentCompleted) {
    return context.count ? new Promise((resolve) => {
      let count = 0;
      context.completed = () => {
        if (++count === context.count) {
          resolve();
        }
        return parentCompleted;
      };
    }) : Promise.resolve();
  }
  async function apply(show3, base, from, to) {
    el = await ensureMountedElement();
    let resolveCompleted = () => {
    };
    const completed = new Promise((resolve) => {
      resolveCompleted = resolve;
    });
    const children = childrenCompleted(completed);
    set(show3);
    addClasses(...base, ...from);
    const transitioned = transitionEnd(base);
    await nextFrame();
    removeClasses(...from);
    addClasses(...to);
    await Promise.all([transitioned, children]);
    if (parent) {
      await parent.completed();
    }
    removeClasses(...base, ...to);
    resolveCompleted();
  }
  async function ensureMountedElement() {
    if (unmount && !mounted) {
      mounted = true;
      await tick();
    }
    return node.firstElementChild;
  }
  async function enter2() {
    dispatch("before-enter");
    display = "contents";
    await apply(true, enterClasses, enterFromClasses, enterToClasses);
    dispatch("after-enter");
  }
  async function leave2() {
    dispatch("before-leave");
    await apply(false, leaveClasses, leaveFromClasses, leaveToClasses);
    display = "none";
    if (unmount) {
      mounted = false;
    }
    dispatch("after-leave");
  }
  let run = context.appear;
  let showPrev;
  function execute(show3) {
    if (show3 === showPrev) {
      return;
    }
    showPrev = show3;
    executing = run ? show3 ? executing.then(enter2) : executing.then(leave2) : Promise.resolve();
    run = true;
  }
  let unsubscribe;
  let executing = Promise.resolve();
  if (parent) {
    parent.count++;
    unsubscribe = parent.show.subscribe(execute);
  } else {
    execute(show2);
  }
  return {
    update(show3) {
      execute(show3);
    },
    destroy() {
      if (parent) {
        unsubscribe();
        parent.count--;
      }
    }
  };
}
</script>

<div style:display use:transition={show}>{#if mounted}<slot />{/if}</div>
