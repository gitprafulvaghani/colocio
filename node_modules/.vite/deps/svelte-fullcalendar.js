import {
  Calendar,
  JsonRequestError,
  createPlugin,
  formatDate,
  formatRange,
  globalLocales,
  globalPlugins,
  sliceEvents,
  version
} from "./chunk-47UFUZ5L.js";
import "./chunk-AYNHEKRI.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-OABNE5IL.js";
import "./chunk-6M2UA5QO.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-WMTNK64S.js";

// node_modules/svelte-fullcalendar/src/FullCalendar.svelte
var file = "node_modules/svelte-fullcalendar/src/FullCalendar.svelte";
function create_fragment(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[0]
      );
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[1]
      );
      add_location(div, file, 58, 0, 1077);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[7](div);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*classes*/
      1) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[0]
        );
      }
      if (dirty & /*style*/
      2) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let canBeInitiated;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FullCalendar", slots, []);
  let { class: classes = null } = $$props;
  let { style = null } = $$props;
  let { options } = $$props;
  function getAPI() {
    return calendar;
  }
  let calendarEl;
  let calendar;
  onMount(async () => {
    initCalendar();
    return () => {
      calendar && calendar.destroy();
    };
  });
  function initCalendar() {
    $$invalidate(5, calendar = new Calendar(calendarEl, options));
    calendar.render();
  }
  function updateCalendarOptions() {
    calendar.pauseRendering();
    calendar.resetOptions(options);
    calendar.resumeRendering();
  }
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<FullCalendar> was created without expected prop 'options'");
    }
  });
  const writable_props = ["class", "style", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<FullCalendar> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      calendarEl = $$value;
      $$invalidate(2, calendarEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2) $$invalidate(0, classes = $$props2.class);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("options" in $$props2) $$invalidate(3, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    onMount,
    Calendar,
    classes,
    style,
    options,
    getAPI,
    calendarEl,
    calendar,
    initCalendar,
    updateCalendarOptions,
    canBeInitiated
  });
  $$self.$inject_state = ($$props2) => {
    if ("classes" in $$props2) $$invalidate(0, classes = $$props2.classes);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("options" in $$props2) $$invalidate(3, options = $$props2.options);
    if ("calendarEl" in $$props2) $$invalidate(2, calendarEl = $$props2.calendarEl);
    if ("calendar" in $$props2) $$invalidate(5, calendar = $$props2.calendar);
    if ("canBeInitiated" in $$props2) $$invalidate(6, canBeInitiated = $$props2.canBeInitiated);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*options, calendarEl, calendar*/
    44) {
      $: $$invalidate(6, canBeInitiated = options && options.plugins && options.plugins.length && calendarEl && !calendar);
    }
    if ($$self.$$.dirty & /*calendar, options, canBeInitiated*/
    104) {
      $: {
        if (calendar && options && options.plugins && options.plugins.length) updateCalendarOptions();
        if (canBeInitiated) {
          initCalendar();
        }
      }
    }
  };
  return [
    classes,
    style,
    calendarEl,
    options,
    getAPI,
    calendar,
    canBeInitiated,
    div_binding
  ];
}
var FullCalendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      class: 0,
      style: 1,
      options: 3,
      getAPI: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FullCalendar",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getAPI() {
    return this.$$.ctx[4];
  }
  set getAPI(value) {
    throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FullCalendar_default = FullCalendar;

// node_modules/svelte-fullcalendar/src/helpers.js
var filterNullProps = (obj) => {
  let result = {};
  for (const key in obj) {
    if (obj[key] != null) result[key] = obj[key];
  }
  return result;
};

// node_modules/svelte-fullcalendar/src/Draggable.svelte
var file2 = "node_modules/svelte-fullcalendar/src/Draggable.svelte";
function create_fragment2(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[0]
      );
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[1]
      );
      add_location(div, file2, 60, 0, 1212);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[11](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      1) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*style*/
      2) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[11](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Draggable", slots, ["default"]);
  let { class: classes = null } = $$props;
  let { style = null } = $$props;
  let { appendTo = null } = $$props;
  let { eventData } = $$props;
  let { itemSelector = null } = $$props;
  let { longPressDelay = null } = $$props;
  let { minDistance = null } = $$props;
  let elementRef = null;
  let draggable = null;
  onMount(async () => {
    if (!draggable && elementRef) initDraggable();
    return () => {
      draggable && draggable.destroy();
    };
  });
  function getFilledProps() {
    const props = {
      appendTo,
      eventData,
      itemSelector,
      longPressDelay,
      minDistance
    };
    return filterNullProps(props);
  }
  async function initDraggable() {
    $$invalidate(8, draggable = new (await import("./@fullcalendar_interaction.js")).Draggable(elementRef, { ...getFilledProps() }));
  }
  $$self.$$.on_mount.push(function() {
    if (eventData === void 0 && !("eventData" in $$props || $$self.$$.bound[$$self.$$.props["eventData"]])) {
      console.warn("<Draggable> was created without expected prop 'eventData'");
    }
  });
  const writable_props = [
    "class",
    "style",
    "appendTo",
    "eventData",
    "itemSelector",
    "longPressDelay",
    "minDistance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Draggable> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRef = $$value;
      $$invalidate(2, elementRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2) $$invalidate(0, classes = $$props2.class);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("appendTo" in $$props2) $$invalidate(3, appendTo = $$props2.appendTo);
    if ("eventData" in $$props2) $$invalidate(4, eventData = $$props2.eventData);
    if ("itemSelector" in $$props2) $$invalidate(5, itemSelector = $$props2.itemSelector);
    if ("longPressDelay" in $$props2) $$invalidate(6, longPressDelay = $$props2.longPressDelay);
    if ("minDistance" in $$props2) $$invalidate(7, minDistance = $$props2.minDistance);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    filterNullProps,
    classes,
    style,
    appendTo,
    eventData,
    itemSelector,
    longPressDelay,
    minDistance,
    elementRef,
    draggable,
    getFilledProps,
    initDraggable
  });
  $$self.$inject_state = ($$props2) => {
    if ("classes" in $$props2) $$invalidate(0, classes = $$props2.classes);
    if ("style" in $$props2) $$invalidate(1, style = $$props2.style);
    if ("appendTo" in $$props2) $$invalidate(3, appendTo = $$props2.appendTo);
    if ("eventData" in $$props2) $$invalidate(4, eventData = $$props2.eventData);
    if ("itemSelector" in $$props2) $$invalidate(5, itemSelector = $$props2.itemSelector);
    if ("longPressDelay" in $$props2) $$invalidate(6, longPressDelay = $$props2.longPressDelay);
    if ("minDistance" in $$props2) $$invalidate(7, minDistance = $$props2.minDistance);
    if ("elementRef" in $$props2) $$invalidate(2, elementRef = $$props2.elementRef);
    if ("draggable" in $$props2) $$invalidate(8, draggable = $$props2.draggable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*draggable, elementRef*/
    260) {
      $: () => {
        draggable && draggable.destroy();
        elementRef && initDraggable();
      };
    }
  };
  return [
    classes,
    style,
    elementRef,
    appendTo,
    eventData,
    itemSelector,
    longPressDelay,
    minDistance,
    draggable,
    $$scope,
    slots,
    div_binding
  ];
}
var Draggable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      class: 0,
      style: 1,
      appendTo: 3,
      eventData: 4,
      itemSelector: 5,
      longPressDelay: 6,
      minDistance: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Draggable",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appendTo() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appendTo(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventData() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventData(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemSelector() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemSelector(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get longPressDelay() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set longPressDelay(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minDistance() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minDistance(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Draggable_default = Draggable;
export {
  Calendar,
  Draggable_default as Draggable,
  JsonRequestError,
  createPlugin,
  FullCalendar_default as default,
  formatDate,
  formatRange,
  globalLocales,
  globalPlugins,
  sliceEvents,
  version
};
//# sourceMappingURL=svelte-fullcalendar.js.map
