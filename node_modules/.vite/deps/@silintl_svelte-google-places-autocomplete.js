import "./chunk-AYNHEKRI.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  assign,
  attr_dev,
  binding_callbacks,
  claim_element,
  createEventDispatcher,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  init,
  insert_hydration_dev,
  listen_dev,
  noop,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  validate_slots
} from "./chunk-OABNE5IL.js";
import "./chunk-6M2UA5QO.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-WMTNK64S.js";

// node_modules/@silintl/svelte-google-places-autocomplete/src/loader.js
var isLoadingLibrary = false;
var callbacks = [];
function hasLoadedLibrary() {
  return window.google && window.google.maps && window.google.maps.places;
}
function loadGooglePlacesLibrary(apiKey, callback) {
  if (hasLoadedLibrary()) {
    callback();
    return;
  }
  callback && callbacks.push(callback);
  if (isLoadingLibrary) {
    return;
  }
  isLoadingLibrary = true;
  const element2 = document.createElement("script");
  element2.async = true;
  element2.defer = true;
  element2.onload = onLibraryLoaded;
  element2.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(
    apiKey
  )}&libraries=places&callback=Function.prototype`;
  element2.type = "text/javascript";
  document.head.appendChild(element2);
}
function onLibraryLoaded() {
  isLoadingLibrary = false;
  let callback;
  while (callback = callbacks.pop()) {
    callback();
  }
}

// node_modules/@silintl/svelte-google-places-autocomplete/src/GooglePlacesAutocomplete.svelte
var file = "node_modules/@silintl/svelte-google-places-autocomplete/src/GooglePlacesAutocomplete.svelte";
function create_fragment(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        placeholder: true,
        pattern: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", input_class_value = /*$$props*/
      ctx[7].class);
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[0]
      );
      input.value = /*value*/
      ctx[1];
      input.required = /*required*/
      ctx[2];
      attr_dev(
        input,
        "pattern",
        /*pattern*/
        ctx[3]
      );
      add_location(input, file, 98, 0, 2928);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[10](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*onKeyDown*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$$props*/
      128 && input_class_value !== (input_class_value = /*$$props*/
      ctx2[7].class)) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*placeholder*/
      1) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[0]
        );
      }
      if (dirty & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[1]
        );
      }
      if (dirty & /*required*/
      4) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[2]
        );
      }
      if (dirty & /*pattern*/
      8) {
        attr_dev(
          input,
          "pattern",
          /*pattern*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let selectedLocationName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GooglePlacesAutocomplete", slots, []);
  let { apiKey } = $$props;
  let { options = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = "" } = $$props;
  let { required = false } = $$props;
  let { pattern = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  let inputField;
  onMount(() => {
    loadGooglePlacesLibrary(apiKey, () => {
      const autocomplete = new google.maps.places.Autocomplete(inputField, options);
      autocomplete.addListener("place_changed", () => {
        const place = autocomplete.getPlace();
        if (hasLocationData(place)) {
          setSelectedLocation({ place, text: inputField.value });
        }
      });
      dispatch("ready");
    });
  });
  function emptyLocationField() {
    $$invalidate(4, inputField.value = "", inputField);
    onChange();
  }
  function hasLocationData(place) {
    var _a;
    const fieldsToLookFor = options && ((_a = options.fields) == null ? void 0 : _a.indexOf("ALL")) === -1 && options.fields || ["geometry"];
    return place.hasOwnProperty(fieldsToLookFor[0]);
  }
  function onChange() {
    if (inputField.value === "") {
      setSelectedLocation(null);
    }
  }
  function onKeyDown(event) {
    const suggestionsAreVisible = document.getElementsByClassName("pac-item").length;
    if (event.key === "Enter" || event.key === "Tab") {
      if (suggestionsAreVisible) {
        const isSuggestionSelected = document.getElementsByClassName("pac-item-selected").length;
        if (!isSuggestionSelected) {
          selectFirstSuggestion();
        }
      } else if (doesNotMatchSelectedLocation(inputField.value)) {
        setTimeout(emptyLocationField, 10);
      }
    } else if (event.key === "Escape") {
      setTimeout(emptyLocationField, 10);
    }
    if (suggestionsAreVisible) {
      if (event.key === "Enter") {
        event.preventDefault();
      }
    }
  }
  function selectFirstSuggestion() {
    const simulatedEvent = new KeyboardEvent(
      "keydown",
      {
        key: "ArrowDown",
        code: "ArrowDown",
        keyCode: 40
      }
    );
    inputField.dispatchEvent(simulatedEvent);
  }
  function setSelectedLocation(data) {
    selectedLocationName = data && data.text || "";
    dispatch("place_changed", data);
  }
  function doesNotMatchSelectedLocation(value2) {
    return selectedLocationName !== value2;
  }
  $$self.$$.on_mount.push(function() {
    if (apiKey === void 0 && !("apiKey" in $$props || $$self.$$.bound[$$self.$$.props["apiKey"]])) {
      console.warn("<GooglePlacesAutocomplete> was created without expected prop 'apiKey'");
    }
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputField = $$value;
      $$invalidate(4, inputField);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("apiKey" in $$new_props) $$invalidate(8, apiKey = $$new_props.apiKey);
    if ("options" in $$new_props) $$invalidate(9, options = $$new_props.options);
    if ("placeholder" in $$new_props) $$invalidate(0, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
    if ("required" in $$new_props) $$invalidate(2, required = $$new_props.required);
    if ("pattern" in $$new_props) $$invalidate(3, pattern = $$new_props.pattern);
  };
  $$self.$capture_state = () => ({
    loadGooglePlacesLibrary,
    createEventDispatcher,
    onMount,
    apiKey,
    options,
    placeholder,
    value,
    required,
    pattern,
    dispatch,
    inputField,
    emptyLocationField,
    hasLocationData,
    onChange,
    onKeyDown,
    selectFirstSuggestion,
    setSelectedLocation,
    doesNotMatchSelectedLocation,
    selectedLocationName
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("apiKey" in $$props) $$invalidate(8, apiKey = $$new_props.apiKey);
    if ("options" in $$props) $$invalidate(9, options = $$new_props.options);
    if ("placeholder" in $$props) $$invalidate(0, placeholder = $$new_props.placeholder);
    if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
    if ("required" in $$props) $$invalidate(2, required = $$new_props.required);
    if ("pattern" in $$props) $$invalidate(3, pattern = $$new_props.pattern);
    if ("inputField" in $$props) $$invalidate(4, inputField = $$new_props.inputField);
    if ("selectedLocationName" in $$props) selectedLocationName = $$new_props.selectedLocationName;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    2) {
      $: selectedLocationName = value || "";
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    placeholder,
    value,
    required,
    pattern,
    inputField,
    onChange,
    onKeyDown,
    $$props,
    apiKey,
    options,
    input_binding
  ];
}
var GooglePlacesAutocomplete = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      apiKey: 8,
      options: 9,
      placeholder: 0,
      value: 1,
      required: 2,
      pattern: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GooglePlacesAutocomplete",
      options,
      id: create_fragment.name
    });
  }
  get apiKey() {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set apiKey(value) {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<GooglePlacesAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GooglePlacesAutocomplete_default = GooglePlacesAutocomplete;
export {
  GooglePlacesAutocomplete_default as default
};
//# sourceMappingURL=@silintl_svelte-google-places-autocomplete.js.map
